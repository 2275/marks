<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. setState | 学习笔记</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Just playing around">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/assets/css/0.styles.a044bf1c.css" as="style"><link rel="preload" href="/assets/js/app.72a8d1bc.js" as="script"><link rel="preload" href="/assets/js/3.bb364767.js" as="script"><link rel="preload" href="/assets/js/23.d84df965.js" as="script"><link rel="prefetch" href="/assets/js/1.5f02ab6c.js"><link rel="prefetch" href="/assets/js/10.84698f87.js"><link rel="prefetch" href="/assets/js/11.c56ba3cf.js"><link rel="prefetch" href="/assets/js/12.d5608a6c.js"><link rel="prefetch" href="/assets/js/13.de737531.js"><link rel="prefetch" href="/assets/js/14.8f37f0b4.js"><link rel="prefetch" href="/assets/js/15.5941db35.js"><link rel="prefetch" href="/assets/js/16.6690db19.js"><link rel="prefetch" href="/assets/js/17.033fe809.js"><link rel="prefetch" href="/assets/js/18.df5ea318.js"><link rel="prefetch" href="/assets/js/19.2c164840.js"><link rel="prefetch" href="/assets/js/20.faf4b905.js"><link rel="prefetch" href="/assets/js/21.2e98ef8a.js"><link rel="prefetch" href="/assets/js/22.17cfd5f5.js"><link rel="prefetch" href="/assets/js/24.dfda0f98.js"><link rel="prefetch" href="/assets/js/25.31e2da5d.js"><link rel="prefetch" href="/assets/js/26.e955b895.js"><link rel="prefetch" href="/assets/js/4.7d86892e.js"><link rel="prefetch" href="/assets/js/5.014e14ca.js"><link rel="prefetch" href="/assets/js/6.18082649.js"><link rel="prefetch" href="/assets/js/7.3fa0e32c.js"><link rel="prefetch" href="/assets/js/8.a7457492.js"><link rel="prefetch" href="/assets/js/9.ef06512f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a044bf1c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/study/" class="nav-link">
  文档
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/study/" class="nav-link">
  文档
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/study/" class="sidebar-link">学习路线</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/react.html" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/react.html#一、todolist-案例相关知识点" class="sidebar-link">一、todoList 案例相关知识点</a></li><li class="sidebar-sub-header"><a href="/react/react.html#二、github-搜索案例相关知识点" class="sidebar-link">二、github 搜索案例相关知识点</a></li><li class="sidebar-sub-header"><a href="/react/react.html#三、路由的基本使用" class="sidebar-link">三、路由的基本使用</a></li><li class="sidebar-sub-header"><a href="/react/react.html#四、路由组件与一般组件" class="sidebar-link">四、路由组件与一般组件</a></li><li class="sidebar-sub-header"><a href="/react/react.html#五、navlink-与封装-navlink" class="sidebar-link">五、NavLink 与封装 NavLink</a></li><li class="sidebar-sub-header"><a href="/react/react.html#六、switch-的使用" class="sidebar-link">六、Switch 的使用</a></li><li class="sidebar-sub-header"><a href="/react/react.html#七、解决多级路径刷新页面样式丢失的问题" class="sidebar-link">七、解决多级路径刷新页面样式丢失的问题</a></li><li class="sidebar-sub-header"><a href="/react/react.html#八、路由的严格匹配与模糊匹配" class="sidebar-link">八、路由的严格匹配与模糊匹配</a></li><li class="sidebar-sub-header"><a href="/react/react.html#九、redirect-的使用" class="sidebar-link">九、Redirect 的使用</a></li><li class="sidebar-sub-header"><a href="/react/react.html#十、嵌套路由" class="sidebar-link">十、嵌套路由</a></li><li class="sidebar-sub-header"><a href="/react/react.html#十一、向路由组件传递参数" class="sidebar-link">十一、向路由组件传递参数</a></li><li class="sidebar-sub-header"><a href="/react/react.html#十二、编程式路由导航" class="sidebar-link">十二、编程式路由导航</a></li><li class="sidebar-sub-header"><a href="/react/react.html#十三、browserrouter-与-hashrouter-的区别" class="sidebar-link">十三、BrowserRouter 与 HashRouter 的区别</a></li><li class="sidebar-sub-header"><a href="/react/react.html#十四、antd-的按需引入-自定主题" class="sidebar-link">十四、antd 的按需引入+自定主题</a></li></ul></li><li><a href="/react/redux.html" class="sidebar-link">redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/redux.html#_1-求和案例-redux精简版" class="sidebar-link">1.求和案例_redux精简版</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_2-求和案例-redux完整版" class="sidebar-link">2.求和案例_redux完整版</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_3-求和案例-redux异步action版" class="sidebar-link">3.求和案例_redux异步action版</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_4-求和案例-react-redux基本使用" class="sidebar-link">4.求和案例_react-redux基本使用</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_5-求和案例-react-redux优化" class="sidebar-link">5.求和案例_react-redux优化</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_6-求和案例-react-redux数据共享版" class="sidebar-link">6.求和案例_react-redux数据共享版</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_7-求和案例-react-redux开发者工具的使用" class="sidebar-link">7.求和案例_react-redux开发者工具的使用</a></li><li class="sidebar-sub-header"><a href="/react/redux.html#_8-求和案例-react-redux最终版" class="sidebar-link">8.求和案例_react-redux最终版</a></li></ul></li><li><a href="/react/ReactRouter6快速上手.html" class="sidebar-link">ReactRouter6快速上手</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/ReactRouter6快速上手.html#_1-概述" class="sidebar-link">1.概述</a></li><li class="sidebar-sub-header"><a href="/react/ReactRouter6快速上手.html#_2-component" class="sidebar-link">2.Component</a></li><li class="sidebar-sub-header"><a href="/react/ReactRouter6快速上手.html#_3-hooks" class="sidebar-link">3.Hooks</a></li></ul></li><li><a href="/react/扩展.html" class="active sidebar-link">扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/扩展.html#_1-setstate" class="sidebar-link">1. setState</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_2-lazyload" class="sidebar-link">2. lazyLoad</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_3-hooks" class="sidebar-link">3. Hooks</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_4-fragment" class="sidebar-link">4. Fragment</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_5-context" class="sidebar-link">5. Context</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_6-组件优化" class="sidebar-link">6. 组件优化</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_7-render-props" class="sidebar-link">7. render props</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_8-错误边界" class="sidebar-link">8. 错误边界</a></li><li class="sidebar-sub-header"><a href="/react/扩展.html#_9-组件通信方式总结" class="sidebar-link">9. 组件通信方式总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-setstate"><a href="#_1-setstate" class="header-anchor">#</a> 1. setState</h2> <h3 id="setstate-更新状态的-2-种写法"><a href="#setstate-更新状态的-2-种写法" class="header-anchor">#</a> setState 更新状态的 2 种写法</h3> <div class="language- extra-class"><pre class="language-text"><code>	(1). setState(stateChange, [callback])------对象式的setState
            1.stateChange为状态改变对象(该对象可以体现出状态的更改)
            2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用

	(2). setState(updater, [callback])------函数式的setState
            1.updater为返回stateChange对象的函数。
            2.updater可以接收到state和props。
            4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。
总结:
		1.对象式的setState是函数式的setState的简写方式(语法糖)
		2.使用原则：
				(1).如果新状态不依赖于原状态 ===&gt; 使用对象方式
				(2).如果新状态依赖于原状态 ===&gt; 使用函数方式
				(3).如果需要在setState()执行后获取最新的状态数据,
					要在第二个callback函数中读取
</code></pre></div><hr> <h2 id="_2-lazyload"><a href="#_2-lazyload" class="header-anchor">#</a> 2. lazyLoad</h2> <h3 id="路由组件的-lazyload"><a href="#路由组件的-lazyload" class="header-anchor">#</a> 路由组件的 lazyLoad</h3> <div class="language-js extra-class"><pre class="language-js"><code>	<span class="token comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span>
	<span class="token keyword">const</span> Login <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/pages/Login'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span>
	<span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>loading<span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Switch<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;/xxx&quot;</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Xxxx<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>Redirect to<span class="token operator">=</span><span class="token string">&quot;/login&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
</code></pre></div><hr> <h2 id="_3-hooks"><a href="#_3-hooks" class="header-anchor">#</a> 3. Hooks</h2> <h4 id="_1-react-hook-hooks-是什么"><a href="#_1-react-hook-hooks-是什么" class="header-anchor">#</a> 1. React Hook/Hooks 是什么?</h4> <div class="language- extra-class"><pre class="language-text"><code>(1). Hook是React 16.8.0版本增加的新特性/新语法
(2). 可以让你在函数组件中使用 state 以及其他的 React 特性
</code></pre></div><h4 id="_2-三个常用的-hook"><a href="#_2-三个常用的-hook" class="header-anchor">#</a> 2. 三个常用的 Hook</h4> <div class="language- extra-class"><pre class="language-text"><code>(1). State Hook: React.useState()
(2). Effect Hook: React.useEffect()
(3). Ref Hook: React.useRef()
</code></pre></div><h4 id="_3-state-hook"><a href="#_3-state-hook" class="header-anchor">#</a> 3. State Hook</h4> <div class="language- extra-class"><pre class="language-text"><code>(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作
(2). 语法: const [xxx, setXxx] = React.useState(initValue)
(3). useState()说明:
        参数: 第一次初始化指定的值在内部作缓存
        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数
(4). setXxx()2种写法:
        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值
        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值
</code></pre></div><h4 id="_4-effect-hook"><a href="#_4-effect-hook" class="header-anchor">#</a> 4. Effect Hook</h4> <div class="language- extra-class"><pre class="language-text"><code>(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)
(2). React中的副作用操作:
        发ajax请求数据获取
        设置订阅 / 启动定时器
        手动更改真实DOM
(3). 语法和说明:
        useEffect(() =&gt; {
          // 在此可以执行任何带副作用操作
          return () =&gt; { // 在组件卸载前执行
            // 在此做一些收尾工作, 比如清除定时器/取消订阅等
          }
        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行

(4). 可以把 useEffect Hook 看做如下三个函数的组合
        componentDidMount()
        componentDidUpdate()
    	componentWillUnmount()
</code></pre></div><h4 id="_5-ref-hook"><a href="#_5-ref-hook" class="header-anchor">#</a> 5. Ref Hook</h4> <div class="language- extra-class"><pre class="language-text"><code>(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据
(2). 语法: const refContainer = useRef()
(3). 作用:保存标签对象,功能与React.createRef()一样
</code></pre></div><hr> <h2 id="_4-fragment"><a href="#_4-fragment" class="header-anchor">#</a> 4. Fragment</h2> <h3 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h3> <div class="language- extra-class"><pre><code>&lt;Fragment&gt;&lt;Fragment&gt;
&lt;&gt;&lt;/&gt;
</code></pre></div><h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <blockquote><p>可以不用必须有一个真实的 DOM 根标签了</p></blockquote> <hr> <h2 id="_5-context"><a href="#_5-context" class="header-anchor">#</a> 5. Context</h2> <h3 id="理解"><a href="#理解" class="header-anchor">#</a> 理解</h3> <blockquote><p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p></blockquote> <h3 id="使用-2"><a href="#使用-2" class="header-anchor">#</a> 使用</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 创建Context容器对象：
	<span class="token keyword">const</span> XxxContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> 渲染子组时，外面包裹xxxContext<span class="token punctuation">.</span>Provider<span class="token punctuation">,</span> 通过value属性给后代组件传递数据：
	<span class="token operator">&lt;</span>xxxContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>数据<span class="token punctuation">}</span><span class="token operator">&gt;</span>
		子组件
    <span class="token operator">&lt;</span><span class="token operator">/</span>xxxContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>

<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> 后代组件读取数据：

	<span class="token comment">//第一种方式:仅适用于类组件</span>
	  <span class="token keyword">static</span> contextType <span class="token operator">=</span> xxxContext  <span class="token comment">// 声明接收context</span>
	  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token comment">// 读取context中的value数据</span>

	<span class="token comment">//第二种方式: 函数组件与类组件都可以</span>
	  <span class="token operator">&lt;</span>xxxContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
	    <span class="token punctuation">{</span>
	      <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span> <span class="token comment">// value就是context中的value数据</span>
	        要显示的内容
	      <span class="token punctuation">)</span>
	    <span class="token punctuation">}</span>
	  <span class="token operator">&lt;</span><span class="token operator">/</span>xxxContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>
</code></pre></div><h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <div class="language- extra-class"><pre><code>在应用开发中一般不用context, 一般都它的封装react插件
</code></pre></div><hr> <h2 id="_6-组件优化"><a href="#_6-组件优化" class="header-anchor">#</a> 6. 组件优化</h2> <h3 id="component-的-2-个问题"><a href="#component-的-2-个问题" class="header-anchor">#</a> Component 的 2 个问题</h3> <blockquote><ol><li><p>只要执行 setState(),即使不改变状态数据, 组件也会重新 render()</p></li> <li><p>只当前组件重新 render(), 就会自动重新 render 子组件 ==&gt; 效率低</p></li></ol></blockquote> <h3 id="效率高的做法"><a href="#效率高的做法" class="header-anchor">#</a> 效率高的做法</h3> <blockquote><p>只有当组件的 state 或 props 数据发生改变时才重新 render()</p></blockquote> <h3 id="原因"><a href="#原因" class="header-anchor">#</a> 原因</h3> <blockquote><p>Component 中的 shouldComponentUpdate()总是返回 true</p></blockquote> <h3 id="解决"><a href="#解决" class="header-anchor">#</a> 解决</h3> <div class="language- extra-class"><pre><code>办法1:
	重写shouldComponentUpdate()方法
	比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
办法2:
	使用PureComponent
	PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
	注意:
		只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false
		不要直接修改state数据, 而是要产生新数据
项目中一般使用PureComponent来优化
</code></pre></div><hr> <h2 id="_7-render-props"><a href="#_7-render-props" class="header-anchor">#</a> 7. render props</h2> <h3 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="header-anchor">#</a> 如何向组件内部动态传入带内容的结构(标签)?</h3> <div class="language- extra-class"><pre><code>Vue中:
	使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;
React中:
	使用children props: 通过组件标签体传入结构
	使用render props: 通过组件标签属性传入结构, 一般用render函数属性
</code></pre></div><h3 id="children-props"><a href="#children-props" class="header-anchor">#</a> children props</h3> <div class="language- extra-class"><pre><code>&lt;A&gt;
  &lt;B&gt;xxxx&lt;/B&gt;
&lt;/A&gt;
{this.props.children}
问题: 如果B组件需要A组件内的数据, ==&gt; 做不到
</code></pre></div><h3 id="render-props"><a href="#render-props" class="header-anchor">#</a> render props</h3> <div class="language- extra-class"><pre><code>&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt;
A组件: {this.props.render(内部state数据)}
C组件: 读取A组件传入的数据显示 {this.props.data}
</code></pre></div><hr> <h2 id="_8-错误边界"><a href="#_8-错误边界" class="header-anchor">#</a> 8. 错误边界</h2> <h4 id="理解-2"><a href="#理解-2" class="header-anchor">#</a> 理解：</h4> <p>错误边界：用来捕获后代组件错误，渲染出备用页面</p> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点：</h4> <p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p> <h5 id="使用方式"><a href="#使用方式" class="header-anchor">#</a> 使用方式：</h5> <p>getDerivedStateFromError 配合 componentDidCatch</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 生命周期函数，一旦后台组件报错，就会触发</span>
<span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在render之前触发</span>
    <span class="token comment">// 返回新的state</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">hasError</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 统计页面的错误。发送请求发送到后台去</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_9-组件通信方式总结"><a href="#_9-组件通信方式总结" class="header-anchor">#</a> 9. 组件通信方式总结</h2> <h4 id="方式"><a href="#方式" class="header-anchor">#</a> 方式：</h4> <div class="language- extra-class"><pre><code>	props：
		(1).children props
		(2).render props
	消息订阅-发布：
		pubs-sub、event等等
	集中式管理：
		redux、dva等等
	conText:
		生产者-消费者模式
</code></pre></div><h4 id="组件间的关系"><a href="#组件间的关系" class="header-anchor">#</a> 组件间的关系</h4> <div class="language- extra-class"><pre><code>	父子组件：props
	兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理
	祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react/ReactRouter6快速上手.html" class="prev">
        ReactRouter6快速上手
      </a></span> <span class="next"><a href="/js/深入JavaScript.html">
        深入JavaScript
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.72a8d1bc.js" defer></script><script src="/assets/js/3.bb364767.js" defer></script><script src="/assets/js/23.d84df965.js" defer></script>
  </body>
</html>
